<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TINAC Example</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: Arial, sans-serif;

        }
        input[type="text"] {
            width: 400px;
            padding: 8px;
            height: 36px;
            margin: 8px 0;
            box-sizing: border-box;
            background-color: #2d2d2d;
            color: #d4d4d4;
            border: 1px solid #555;
        }
        button {
            background-color: #007acc;
            color: white;
            height: 36px;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
        }

        input[type="range"] {
            width: 400px;
            margin: 8px 0;
        }
        button:hover {
            background-color: #005f99;
        }
        pre {
            font-family: "Courier New", Courier, monospace;
            line-height: 1;
            font-size: 12px;
        }

        
    </style>
</head>
<body>
    <h1>TINAC Captcha example</h1>
    <!-- In a production environment the API URL should not be taken like this in an input-->
    <p>API URL:</p>
    <input type="text" id="api_url" value="http://tanjim.duckdns.org:3456"><button onclick="fetchCaptchaImg()">Fetch Captcha</button>
    <br><button onclick="fetchCaptcha()">Fetch Legacy Text Captcha</button> <button onclick="fetchAudioCaptcha()">Fetch Audio Captcha</button>
    <p>Note: It may take some time to fetch. Wait until you see the captcha below.</p>
    <canvas id="captcha_canvas" style="display:none; border:1px solid #555;"></canvas>
    <div id="captcha_container">
        <pre id="captcha_display">Click "Fetch Captcha" or "Fetch Audio Captcha" to start.</pre>
        <p id="instruct">Slowly drag the slider until you see legible text. Then enter the text you see in the input box below.</p>
        <div id="audio" style="display:none;">
            <audio id="captcha_audio" controls>
                Your browser does not support the audio element.
            </audio>
            <button onclick="previousTrack()">Previous</button>&nbsp;<button onclick="nextTrack()">Next</button> 
        </div>
        <input type="range" id="captcha_slider" min="0" max="1" value="0" oninput="updateSliderValue()"> <span id="selected_index">0</span>
        <br><input type="text" id="answer_input" placeholder="Enter captcha text here"><button onclick="submitCaptcha()">Submit Captcha</button>
    </div>
    
    <div id="result"></div>
    <script>
        function hexToRgb(hex) {
    // Remove '#' if present
    hex = hex.replace(/^#/, '');
    
    // Parse the values
    const bigint = parseInt(hex, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;

    return { r, g, b };
        }       
        function fetchCaptcha() {
            const apiUrl = document.getElementById('api_url').value;
            const captchaDisplay = document.getElementById('captcha_display');
            captchaDisplay.textContent = "Fetching captcha, please wait...";
            fetch(`${apiUrl}/challenge`)
                .then(response => response.json())
                .then(data => {
                    window.captchaId = data.id;
                    window.captchaChallenges = data.challenge;
                    document.getElementById('captcha_slider').max = data.steps - 1;
                    updateCaptchaDisplay(0);
                })
                .catch(error => {
                    captchaDisplay.textContent = "Error fetching captcha: " + error;
                });
        }
        // GLOBAL STORAGE for the decompressed raw bits
window.captchaRawBits = null; 

async function initCaptchaData() {
    if (!window.challenges || !window.challenges.data) {
        console.error("No captcha data found in window.challenges");
        return;
    }

    try {
        // 1. Convert Base64 string to Uint8Array
        const binaryString = atob(window.challenges.data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }

        // 2. Decompress using native browser API
        // 'deflate' format handles the zlib headers Python generates
        const stream = new Blob([bytes]).stream().pipeThrough(
            new DecompressionStream("deflate")
        );
        
        // 3. Load result into memory buffer
        const response = new Response(stream);
        const buffer = await response.arrayBuffer();
        window.captchaRawBits = new Uint8Array(buffer);
        
        console.log(`Captcha loaded: ${window.captchaRawBits.length} bytes unpacked.`);
        
        // Optional: Draw the first frame immediately
        display_to_canvas(0);

    } catch (err) {
        console.error("Decompression failed:", err);
    }
}

function display_to_canvas(index, fgHex = "#d4d4d4", bgHex = "transparent" /*bgHex can be "transparent" or a hexcode*/) {
    const rawData = window.captchaRawBits;
    const meta = window.challenges;
    const canvas = window.canvasElem;

    if (!rawData || !canvas || !meta) return;
    if (index < 0 || index >= meta.count) return;

    if (canvas.width !== meta.width || canvas.height !== meta.height) {
        canvas.width = meta.width;
        canvas.height = meta.height;
    }

    const ctx = canvas.getContext("2d");
    const imgData = ctx.createImageData(meta.width, meta.height);
    const pixels = imgData.data;

    const fg = hexToRgb(fgHex);
    let bg = { r: 0, g: 0, b: 0 }; 
    let bgAlpha = 255; 

    if (bgHex === "transparent") {
        bgAlpha = 0; 
    } else {
        bg = hexToRgb(bgHex);
    }

    const totalPixels = meta.width * meta.height;
    const bytesPerFrame = Math.ceil(totalPixels / 8);
    const startByte = index * bytesPerFrame;

    for (let i = 0; i < totalPixels; i++) {
        const byteIndex = startByte + (i >> 3); 
        const bitPos = 7 - (i % 8); 

        const byteVal = (byteIndex < rawData.length) ? rawData[byteIndex] : 0;
        const isInk = (byteVal >> bitPos) & 1;

        const p = i * 4;
        
        if (isInk === 1) {
            pixels[p]     = fg.r;
            pixels[p + 1] = fg.g;
            pixels[p + 2] = fg.b;
            pixels[p + 3] = 255; 
        } else {
            pixels[p]     = bg.r;
            pixels[p + 1] = bg.g;
            pixels[p + 2] = bg.b;
            pixels[p + 3] = bgAlpha; 
        }
    }

    ctx.putImageData(imgData, 0, 0);
}
window.canvasElem=document.getElementById("captcha_canvas");
// GLOBAL STORAGE for the decompressed raw bits
window.captchaRawBits = null; 

async function initCaptchaData() {
    if (!window.challenges || !window.challenges.data) {
        console.error("No captcha data found in window.challenges");
        return;
    }

    try {
        const binaryString = atob(window.challenges.data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }

        const stream = new Blob([bytes]).stream().pipeThrough(
            new DecompressionStream("deflate")
        );
        
        const response = new Response(stream);
        const buffer = await response.arrayBuffer();
        window.captchaRawBits = new Uint8Array(buffer);
        
        console.log(`Captcha loaded: ${window.captchaRawBits.length} bytes unpacked.`);
        display_to_canvas(0);

    } catch (err) {
        console.error("Decompression failed:", err);
    }
}

    function fetchCaptchaImg() {
            const apiUrl = document.getElementById('api_url').value;
            const captchaDisplay = document.getElementById('captcha_display');
            const canvas = document.getElementById('captcha_canvas');
            canvas.style.display = "block";
            captchaDisplay.style.display = "none";
            captchaDisplay.textContent = "Fetching image captcha, please wait...";
            fetch(`${apiUrl}/challenge_img`)
                .then(response => response.json())
                .then(data => {
                    window.captchaId = data.id;
                    window.challenges = data.challenge;
                    document.getElementById('captcha_slider').max = data.steps - 1;
                    initCaptchaData();
                })
                .catch(error => {
                    captchaDisplay.textContent = "Error fetching captcha: " + error;
                });
        }
        function updateCaptchaDisplay(index) {
            const captchaDisplay = document.getElementById('captcha_display');
            captchaDisplay.textContent = window.captchaChallenges[index];
        }

        function playCaptchaAudio(audioData) {
            const binaryString = window.atob(audioData);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const blob = new Blob([bytes], { type: 'audio/mpeg' });
            const url = URL.createObjectURL(blob);
            const audioElem = document.getElementById('captcha_audio');
            audioElem.src = url;
            audioElem.play();
        }
        function updateAudioCaptchaDisplay(index) {
            playCaptchaAudio(window.challenges[index]);
        }
        function nextTrack(){
            window.currentAudioIndex = (window.currentAudioIndex + 1) % window.audioSteps;
            document.getElementById('captcha_slider').value = window.currentAudioIndex;
            updateAudioCaptchaDisplay(window.currentAudioIndex);
        }
        function previousTrack(){
            window.currentAudioIndex = (window.currentAudioIndex - 1 + window.audioSteps) % window.audioSteps;
            document.getElementById('captcha_slider').value = window.currentAudioIndex;
            updateAudioCaptchaDisplay(window.currentAudioIndex);
        }
        function fetchAudioCaptcha(){
            const apiUrl = document.getElementById('api_url').value;
            const captchaDisplay = document.getElementById('captcha_display');
            captchaDisplay.textContent = "Fetching audio captcha, please wait...";
            fetch(`${apiUrl}/challenge_audio`)
                .then(response => response.json())
                .then(data =>{
                    captchaDisplay.textContent=""; 
                    document.getElementById('instruct').textContent="Click 'Next' or drag the slider until you hear numbers. Enter the numbers (not words) you hear in the input box below.";
                    window.captchaId = data.id
                    window.challenges = data.challenge;
                    document.getElementById('captcha_slider').max = data.steps - 1;
                    document.getElementById('audio').style.display="block";
                    window.audioSteps = data.steps;

                })
        }









        function updateSliderValue() {
            const slider = document.getElementById('captcha_slider');
            const selectedIndex = document.getElementById('selected_index');
            selectedIndex.textContent = slider.value;
            if(window.audioSteps){
                updateAudioCaptchaDisplay(parseInt(slider.value));// Audio captcha
                return;
            }
            if(window.captchaRawBits==null){
                updateCaptchaDisplay(slider.value);// Text captcha
            }else{
                display_to_canvas(parseInt(slider.value));// Image captcha
            }
        }




        function submitCaptcha() {
            const apiUrl = document.getElementById('api_url').value;
            const answer = document.getElementById('answer_input').value;
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = "Submitting captcha, please wait...";
            fetch(`${apiUrl}/verify`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    id: window.captchaId,
                    answer: answer,
                    index: parseInt(document.getElementById('captcha_slider').value)
                })
            })
            .then(response => response.json())
            .then(data => {
                
                resultDiv.innerText = `Answer is  ${data.answer == true ? "correct" : "incorrect"}, Index is ${data.index == true ? "correct" : "incorrect"}. JWT token: ${data.token ? data.token : "No token received."} ${data.error ? ("AN ERROR OCCURED! " + data.error) : ""}\n Verifying JWT token...`;
                if(data.token){
                    fetch(`${apiUrl}/verify_token`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            token: data.token
                        })
                    })
                    .then(response => response.json())
                    .then(tokenData => {
                        resultDiv.innerText += `\nToken verification result: ${tokenData.valid ? "Valid" : "Invalid"}. Payload: ${tokenData.data?JSON.stringify(tokenData.data):"None"}, Error: ${tokenData.error ? tokenData.error : "None"}`;
                    })
                    .catch(error => {
                        resultDiv.textContent += "\nNetwork/https error verifying token: " + error;
                    });
                }
            }).catch(error => {
                resultDiv.textContent = "Network/https error submitting captcha: " + error;
            });
        }
    </script>
</body>
</html>